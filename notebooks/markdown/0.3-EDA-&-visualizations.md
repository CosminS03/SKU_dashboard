```python
import pandas as pd

df = pd.read_csv("../data/interim/online_retail_no_outliers.csv", dtype={"InvoiceNo": str})
```


```python
df["InvoiceDate"] = pd.to_datetime(df["InvoiceDate"])
```


```python
def calc_units(df: pd.DataFrame, year: int, sold: bool):
    if sold:
        return (
            df[df["InvoiceDate"].dt.year == year][~df["InvoiceNo"].str.startswith("C")]
            .groupby(by="SKU")["Quantity"]
            .sum()
            .reset_index()
        )
    else:
        return (
            df[df["InvoiceDate"].dt.year == year][df["InvoiceNo"].str.startswith("C")]
            .groupby(by="SKU")["Quantity"]
            .sum()
            .abs()
            .reset_index()
        )
```


```python
units_sold_2010 = calc_units(df, 2010, True)
units_bought_2010 = calc_units(df, 2010, False)
units_sold_2011 = calc_units(df, 2011, True)
units_bought_2011 = calc_units(df, 2011, False)
```

    C:\Users\spanu\AppData\Local\Temp\ipykernel_2784\1229763443.py:4: UserWarning: Boolean Series key will be reindexed to match DataFrame index.
      df[df["InvoiceDate"].dt.year == year][~df["InvoiceNo"].str.startswith("C")]
    C:\Users\spanu\AppData\Local\Temp\ipykernel_2784\1229763443.py:11: UserWarning: Boolean Series key will be reindexed to match DataFrame index.
      df[df["InvoiceDate"].dt.year == year][df["InvoiceNo"].str.startswith("C")]
    C:\Users\spanu\AppData\Local\Temp\ipykernel_2784\1229763443.py:4: UserWarning: Boolean Series key will be reindexed to match DataFrame index.
      df[df["InvoiceDate"].dt.year == year][~df["InvoiceNo"].str.startswith("C")]
    C:\Users\spanu\AppData\Local\Temp\ipykernel_2784\1229763443.py:11: UserWarning: Boolean Series key will be reindexed to match DataFrame index.
      df[df["InvoiceDate"].dt.year == year][df["InvoiceNo"].str.startswith("C")]
    


```python
str_2010 = pd.merge(units_sold_2010, units_bought_2010, on='SKU', how='outer', suffixes=('_sold', '_bought'))
```


```python
import numpy as np

str_2010 = str_2010.fillna(0)

str_2010['Sell_through_rate'] = (str_2010["Quantity_sold"] / str_2010["Quantity_bought"]) * 100

str_2010['Sell_through_rate'] = str_2010['Sell_through_rate'].replace([np.inf, -np.inf], 0)
```


```python
str_2010.sort_values(by='Sell_through_rate', ascending=False).head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SKU</th>
      <th>Quantity_sold</th>
      <th>Quantity_bought</th>
      <th>Sell_through_rate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>572</th>
      <td>22536</td>
      <td>119.0</td>
      <td>11.0</td>
      <td>1081.818182</td>
    </tr>
    <tr>
      <th>778</th>
      <td>84685</td>
      <td>10.0</td>
      <td>1.0</td>
      <td>1000.000000</td>
    </tr>
    <tr>
      <th>744</th>
      <td>79164</td>
      <td>24.0</td>
      <td>3.0</td>
      <td>800.000000</td>
    </tr>
    <tr>
      <th>822</th>
      <td>85175</td>
      <td>16.0</td>
      <td>2.0</td>
      <td>800.000000</td>
    </tr>
    <tr>
      <th>261</th>
      <td>21411</td>
      <td>46.0</td>
      <td>6.0</td>
      <td>766.666667</td>
    </tr>
    <tr>
      <th>651</th>
      <td>22869</td>
      <td>7.0</td>
      <td>1.0</td>
      <td>700.000000</td>
    </tr>
    <tr>
      <th>87</th>
      <td>20798</td>
      <td>26.0</td>
      <td>4.0</td>
      <td>650.000000</td>
    </tr>
    <tr>
      <th>659</th>
      <td>22877</td>
      <td>6.0</td>
      <td>1.0</td>
      <td>600.000000</td>
    </tr>
    <tr>
      <th>715</th>
      <td>47580</td>
      <td>57.0</td>
      <td>12.0</td>
      <td>475.000000</td>
    </tr>
    <tr>
      <th>364</th>
      <td>21777</td>
      <td>12.0</td>
      <td>5.0</td>
      <td>240.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
str_2011=pd.merge(units_sold_2011, units_bought_2011, on='SKU', how='outer', suffixes=['_sold', '_bought'])
```


```python
str_2011 = str_2011.fillna(0)

str_2011['Sell_through_rate'] = (str_2011['Quantity_sold'] / str_2011['Quantity_bought']) * 100
str_2011['Sell_through_rate'] = str_2011['Sell_through_rate'].replace([np.inf, -np.inf], 0)
```


```python
str_2011.sort_values(by='Sell_through_rate', ascending=False).head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SKU</th>
      <th>Quantity_sold</th>
      <th>Quantity_bought</th>
      <th>Sell_through_rate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>359</th>
      <td>21655</td>
      <td>36.0</td>
      <td>36.0</td>
      <td>100.000000</td>
    </tr>
    <tr>
      <th>1081</th>
      <td>72815</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>50.000000</td>
    </tr>
    <tr>
      <th>474</th>
      <td>22034</td>
      <td>2.0</td>
      <td>12.0</td>
      <td>16.666667</td>
    </tr>
    <tr>
      <th>1255</th>
      <td>90094</td>
      <td>11.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>22</th>
      <td>16225</td>
      <td>399.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>1271</th>
      <td>90138</td>
      <td>9.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>1270</th>
      <td>90137</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>7</th>
      <td>16008</td>
      <td>898.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>1286</th>
      <td>90194</td>
      <td>12.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>15030</td>
      <td>83.0</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
from src import config

sku_str = pd.merge(str_2010, str_2011, on='SKU', how='outer', suffixes=['_10', '_11'])

sku_str = sku_str.fillna(0)

sku_str['Sell_through_rate'] = (config.wght_2010 * sku_str['Sell_through_rate_10'] +
                                config.wght_2011 * sku_str['Sell_through_rate_11'])
```


```python
sku_str.sort_values(by='Sell_through_rate', ascending=False).head(10)[
    ['SKU', 'Sell_through_rate_10', 'Sell_through_rate_11', 'Sell_through_rate']
]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SKU</th>
      <th>Sell_through_rate_10</th>
      <th>Sell_through_rate_11</th>
      <th>Sell_through_rate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>648</th>
      <td>22536</td>
      <td>1081.818182</td>
      <td>0.0</td>
      <td>97.363636</td>
    </tr>
    <tr>
      <th>371</th>
      <td>21655</td>
      <td>0.000000</td>
      <td>100.0</td>
      <td>91.000000</td>
    </tr>
    <tr>
      <th>1169</th>
      <td>84685</td>
      <td>1000.000000</td>
      <td>0.0</td>
      <td>90.000000</td>
    </tr>
    <tr>
      <th>1111</th>
      <td>79164</td>
      <td>800.000000</td>
      <td>0.0</td>
      <td>72.000000</td>
    </tr>
    <tr>
      <th>1236</th>
      <td>85175</td>
      <td>800.000000</td>
      <td>0.0</td>
      <td>72.000000</td>
    </tr>
    <tr>
      <th>300</th>
      <td>21411</td>
      <td>766.666667</td>
      <td>0.0</td>
      <td>69.000000</td>
    </tr>
    <tr>
      <th>738</th>
      <td>22869</td>
      <td>700.000000</td>
      <td>0.0</td>
      <td>63.000000</td>
    </tr>
    <tr>
      <th>98</th>
      <td>20798</td>
      <td>650.000000</td>
      <td>0.0</td>
      <td>58.500000</td>
    </tr>
    <tr>
      <th>746</th>
      <td>22877</td>
      <td>600.000000</td>
      <td>0.0</td>
      <td>54.000000</td>
    </tr>
    <tr>
      <th>1099</th>
      <td>72815</td>
      <td>0.000000</td>
      <td>50.0</td>
      <td>45.500000</td>
    </tr>
  </tbody>
</table>
</div>




```python
from src import plots

plots.waterfall_plot(df, True)
```

    C:\Users\spanu\Desktop\SKU_dashboard\src\plots.py:101: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:
    
    df["col"][row_indexer] = value
    
    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    
      waterfall["Measure"].iloc[-1] = "total"
    C:\Users\spanu\Desktop\SKU_dashboard\src\plots.py:101: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
      waterfall["Measure"].iloc[-1] = "total"
    


![Cash inflows plot](markdown/plotly-images/cash_inflows.png)

```python
plots.waterfall_plot(df, False)
```

    C:\Users\spanu\Desktop\SKU_dashboard\src\plots.py:101: FutureWarning:
    
    ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:
    
    df["col"][row_indexer] = value
    
    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    
    
    C:\Users\spanu\Desktop\SKU_dashboard\src\plots.py:101: SettingWithCopyWarning:
    
    
    A value is trying to be set on a copy of a slice from a DataFrame
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    
    



![Cash outflows plot](markdown/plotly-images/cash_outflows.png)
